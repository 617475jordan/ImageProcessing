///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);

// Procedures 
// External procedures 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_BufferWindowHandle, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_Scale, hv_Exception;
  HTuple  hv_SubFamily, hv_Fonts, hv_SystemFonts, hv_Guess;
  HTuple  hv_I, hv_Index, hv_AllowedFontSizes, hv_Distances;
  HTuple  hv_Indices, hv_FontSelRegexp, hv_FontsCourier;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Set font on Windows systems
    try
    {
      //Check, if font scaling is switched on
      OpenWindow(0, 0, 256, 256, 0, "buffer", "", &hv_BufferWindowHandle);
      SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
      GetStringExtents(hv_BufferWindowHandle, "test_string", &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      //Expected width is 110
      hv_Scale = 110.0/hv_Width;
      hv_Size = (hv_Size*hv_Scale).TupleInt();
      CloseWindow(hv_BufferWindowHandle);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
    if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Font = "Courier New";
    }
    else if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Font = "Consolas";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "Times New Roman";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = 1;
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_Slant = 1;
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-"+hv_Font)+"-")+hv_Size)+"-*-")+hv_Slant)+"-*-*-")+hv_Bold)+"-");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Dar")))
  {
    //Set font on Mac OS X systems. Since OS X does not have a strict naming
    //scheme for font attributes, we use tables to determine the correct font
    //name.
    hv_SubFamily = 0;
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|1;
    }
    else if (0 != (hv_Slant!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|2;
    }
    else if (0 != (hv_Bold!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "Menlo-Regular";
      hv_Fonts[1] = "Menlo-Italic";
      hv_Fonts[2] = "Menlo-Bold";
      hv_Fonts[3] = "Menlo-BoldItalic";
    }
    else if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "CourierNewPSMT";
      hv_Fonts[1] = "CourierNewPS-ItalicMT";
      hv_Fonts[2] = "CourierNewPS-BoldMT";
      hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "ArialMT";
      hv_Fonts[1] = "Arial-ItalicMT";
      hv_Fonts[2] = "Arial-BoldMT";
      hv_Fonts[3] = "Arial-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "TimesNewRomanPSMT";
      hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
      hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
      hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
    }
    else
    {
      //Attempt to figure out which of the fonts installed on the system
      //the user could have meant.
      QueryFont(hv_WindowHandle, &hv_SystemFonts);
      hv_Fonts.Clear();
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font);
      hv_Guess.Append(hv_Font+"-Regular");
      hv_Guess.Append(hv_Font+"MT");
      {
      HTuple end_val100 = (hv_Guess.TupleLength())-1;
      HTuple step_val100 = 1;
      for (hv_I=0; hv_I.Continue(end_val100, step_val100); hv_I += step_val100)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[0] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Italic");
      hv_Guess.Append(hv_Font+"-ItalicMT");
      hv_Guess.Append(hv_Font+"-Oblique");
      {
      HTuple end_val109 = (hv_Guess.TupleLength())-1;
      HTuple step_val109 = 1;
      for (hv_I=0; hv_I.Continue(end_val109, step_val109); hv_I += step_val109)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[1] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Bold");
      hv_Guess.Append(hv_Font+"-BoldMT");
      {
      HTuple end_val118 = (hv_Guess.TupleLength())-1;
      HTuple step_val118 = 1;
      for (hv_I=0; hv_I.Continue(end_val118, step_val118); hv_I += step_val118)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[2] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-BoldItalic");
      hv_Guess.Append(hv_Font+"-BoldItalicMT");
      hv_Guess.Append(hv_Font+"-BoldOblique");
      {
      HTuple end_val127 = (hv_Guess.TupleLength())-1;
      HTuple step_val127 = 1;
      for (hv_I=0; hv_I.Continue(end_val127, step_val127); hv_I += step_val127)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[3] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
    }
    hv_Font = ((const HTuple&)hv_Fonts)[hv_SubFamily];
    try
    {
      SetFont(hv_WindowHandle, (hv_Font+"-")+hv_Size);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else
  {
    //Set font for UNIX systems
    hv_Size = hv_Size*1.25;
    hv_AllowedFontSizes.Clear();
    hv_AllowedFontSizes[0] = 11;
    hv_AllowedFontSizes[1] = 14;
    hv_AllowedFontSizes[2] = 17;
    hv_AllowedFontSizes[3] = 20;
    hv_AllowedFontSizes[4] = 25;
    hv_AllowedFontSizes[5] = 34;
    if (0 != ((hv_AllowedFontSizes.TupleFind(hv_Size))==-1))
    {
      hv_Distances = (hv_AllowedFontSizes-hv_Size).TupleAbs();
      TupleSortIndex(hv_Distances, &hv_Indices);
      hv_Size = ((const HTuple&)hv_AllowedFontSizes)[HTuple(hv_Indices[0])];
    }
    if (0 != (HTuple(hv_Font==HTuple("mono")).TupleOr(hv_Font==HTuple("Courier"))))
    {
      hv_Font = "courier";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "helvetica";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "times";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = "bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = "medium";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      if (0 != (hv_Font==HTuple("times")))
      {
        hv_Slant = "i";
      }
      else
      {
        hv_Slant = "o";
      }
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = "r";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font)+"-")+hv_Bold)+"-")+hv_Slant)+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple((hv_OS.TupleSubstr(0,4))==HTuple("Linux")).TupleAnd(hv_Font==HTuple("courier"))))
      {
        QueryFont(hv_WindowHandle, &hv_Fonts);
        hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold)+"-")+hv_Slant;
        hv_FontsCourier = (hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp)).TupleRegexpMatch(hv_FontSelRegexp);
        if (0 != ((hv_FontsCourier.TupleLength())==0))
        {
          hv_Exception = "Wrong font name";
          //throw (Exception)
        }
        else
        {
          try
          {
            SetFont(hv_WindowHandle, ((HTuple(hv_FontsCourier[0])+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
          }
          // catch (Exception) 
          catch (HalconCpp::HException &HDevExpDefaultException)
          {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            //throw (Exception)
          }
        }
      }
      //throw (Exception)
    }
  }
  // dev_set_preferences(...); only in hdevelop
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Rectangle, ho_Rectangle1;
  HObject  ho_Rectangle2, ho_ImageReduced, ho_ShapeModel, ho_ShapeModelTrans;
  HObject  ho_ImageCheck, ho_Rectangle1Check, ho_Rectangle2Check;

  // Local control variables
  HTuple  hv_Error;
  HTuple  hv_FGHandle, hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_WindowHandleText, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Area, hv_Row, hv_Column, hv_Rect1Row;
  HTuple  hv_Rect1Col, hv_Rect2Row, hv_Rect2Col, hv_RectPhi;
  HTuple  hv_RectLength1, hv_RectLength2, hv_ModelID, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DTranslate, hv_Row3, hv_Column3, hv_Button1;
  HTuple  hv_Button, hv_S1, hv_RowCheck, hv_ColumnCheck, hv_AngleCheck;
  HTuple  hv_Score, hv_S2, hv_HomMat2DRotate, hv_Rect1RowCheck;
  HTuple  hv_Rect1ColCheck, hv_Rect2RowCheck, hv_Rect2ColCheck;
  HTuple  hv_S3, hv_MeasureHandle1, hv_MeasureHandle2, hv_RowEdgeFirst1;
  HTuple  hv_ColumnEdgeFirst1, hv_AmplitudeFirst1, hv_RowEdgeSecond1;
  HTuple  hv_ColumnEdgeSecond1, hv_AmplitudeSecond1, hv_IntraDistance1;
  HTuple  hv_InterDistance1, hv_RowEdgeFirst2, hv_ColumnEdgeFirst2;
  HTuple  hv_AmplitudeFirst2, hv_RowEdgeSecond2, hv_ColumnEdgeSecond2;
  HTuple  hv_AmplitudeSecond2, hv_IntraDistance2, hv_InterDistance2;
  HTuple  hv_S4, hv_NumLeads, hv_MinDistance, hv_R, hv_C;

  // dev_update_pc(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  OpenFramegrabber("File", 1, 1, 0, 0, 0, 0, "default", -1, "default", -1, "default", 
      "board/board.seq", "default", -1, 1, &hv_FGHandle);
  GrabImage(&ho_Image, hv_FGHandle);
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width,hv_Height,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Height+70,0,hv_Width,120,0,"","",&hv_WindowHandleText);
  HDevWindowStack::Push(hv_WindowHandleText);
  HDevWindowStack::SetActive(hv_WindowHandle);
  set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
  set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"red");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  //**设置roi区域的大小，方便修改
  hv_Row1 = 188;
  hv_Column1 = 182;
  hv_Row2 = 298;
  hv_Column2 = 412;
  GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
  AreaCenter(ho_Rectangle, &hv_Area, &hv_Row, &hv_Column);
  hv_Rect1Row = -102;
  hv_Rect1Col = 5;
  hv_Rect2Row = 107;
  hv_Rect2Col = 5;
  hv_RectPhi = 0;
  hv_RectLength1 = 170;
  hv_RectLength2 = 5;
  GenRectangle2(&ho_Rectangle1, hv_Row+hv_Rect1Row, hv_Column+hv_Rect1Col, hv_RectPhi, 
      hv_RectLength1, hv_RectLength2);
  GenRectangle2(&ho_Rectangle2, hv_Row+hv_Rect2Row, hv_Column+hv_Rect2Col, hv_RectPhi, 
      hv_RectLength1, hv_RectLength2);
  ReduceDomain(ho_Image, ho_Rectangle, &ho_ImageReduced);
  //**参数含义依次为 选取的模板图像、金字塔的水平、最小旋转角度、匹配对象的旋转角度范围、角度步长、模型产生的方式、匹配标准、
  //**模板的中对象与背景阈值对比以及模板的尺寸、在图像的中的最小对比度。
  CreateShapeModel(ho_ImageReduced, 4, 0, HTuple(360).TupleRad(), HTuple(1).TupleRad(), 
      "none", "use_polarity", 30, 10, &hv_ModelID);
  GetShapeModelContours(&ho_ShapeModel, hv_ModelID, 1);
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dTranslate(hv_HomMat2DIdentity, hv_Row, hv_Column, &hv_HomMat2DTranslate);
  AffineTransContourXld(ho_ShapeModel, &ho_ShapeModelTrans, hv_HomMat2DTranslate);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ShapeModelTrans, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"blue");
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),3);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Rectangle1, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Rectangle2, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"fill");
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),1);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"yellow");
  disp_message(hv_WindowHandle, (HTuple("Press left button to start").Append("and stop the demo")), 
      "image", 12, 12, "black", "true");
  GetMbutton(hv_WindowHandle, &hv_Row3, &hv_Column3, &hv_Button1);
  WaitSeconds(0.5);
  hv_Button = 0;
  while (0 != (hv_Button!=1))
  {
    HDevWindowStack::SetActive(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
    GrabImage(&ho_ImageCheck, hv_FGHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageCheck, HDevWindowStack::GetActive());
    //**count_second***计算从开始S1到S2中算子所用时间
    CountSeconds(&hv_S1);
    //**模板搜索***
    FindShapeModel(ho_ImageCheck, hv_ModelID, 0, HTuple(360).TupleRad(), 0.7, 1, 
        0.5, "least_squares", 4, 0.7, &hv_RowCheck, &hv_ColumnCheck, &hv_AngleCheck, 
        &hv_Score);
    CountSeconds(&hv_S2);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageCheck, HDevWindowStack::GetActive());
    //**显示找到的模板图像
    if (0 != ((hv_Score.TupleLength())>0))
    {
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"green");
      HomMat2dIdentity(&hv_HomMat2DIdentity);
      HomMat2dTranslate(hv_HomMat2DIdentity, hv_RowCheck, hv_ColumnCheck, &hv_HomMat2DTranslate);
      HomMat2dRotate(hv_HomMat2DTranslate, hv_AngleCheck, hv_RowCheck, hv_ColumnCheck, 
          &hv_HomMat2DRotate);
      AffineTransContourXld(ho_ShapeModel, &ho_ShapeModelTrans, hv_HomMat2DRotate);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ShapeModelTrans, HDevWindowStack::GetActive());
      //*****利用仿射变换对于划定ROI区域做位置变换*****
      AffineTransPixel(hv_HomMat2DRotate, hv_Rect1Row, hv_Rect1Col, &hv_Rect1RowCheck, 
          &hv_Rect1ColCheck);
      AffineTransPixel(hv_HomMat2DRotate, hv_Rect2Row, hv_Rect2Col, &hv_Rect2RowCheck, 
          &hv_Rect2ColCheck);
      GenRectangle2(&ho_Rectangle1Check, hv_Rect1RowCheck, hv_Rect1ColCheck, hv_AngleCheck, 
          hv_RectLength1, hv_RectLength2);
      GenRectangle2(&ho_Rectangle2Check, hv_Rect2RowCheck, hv_Rect2ColCheck, hv_AngleCheck, 
          hv_RectLength1, hv_RectLength2);
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"blue");
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),3);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Rectangle1Check, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Rectangle2Check, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"fill");
      CountSeconds(&hv_S3);
      GenMeasureRectangle2(hv_Rect1RowCheck, hv_Rect1ColCheck, hv_AngleCheck, hv_RectLength1, 
          hv_RectLength2, hv_Width, hv_Height, "bilinear", &hv_MeasureHandle1);
      GenMeasureRectangle2(hv_Rect2RowCheck, hv_Rect2ColCheck, hv_AngleCheck, hv_RectLength1, 
          hv_RectLength2, hv_Width, hv_Height, "bilinear", &hv_MeasureHandle2);

      MeasurePairs(ho_ImageCheck, hv_MeasureHandle1, 2, 90, "positive", "all", &hv_RowEdgeFirst1, 
          &hv_ColumnEdgeFirst1, &hv_AmplitudeFirst1, &hv_RowEdgeSecond1, &hv_ColumnEdgeSecond1, 
          &hv_AmplitudeSecond1, &hv_IntraDistance1, &hv_InterDistance1);
      MeasurePairs(ho_ImageCheck, hv_MeasureHandle2, 2, 90, "positive", "all", &hv_RowEdgeFirst2, 
          &hv_ColumnEdgeFirst2, &hv_AmplitudeFirst2, &hv_RowEdgeSecond2, &hv_ColumnEdgeSecond2, 
          &hv_AmplitudeSecond2, &hv_IntraDistance2, &hv_InterDistance2);
      CloseMeasure(hv_MeasureHandle1);
      CloseMeasure(hv_MeasureHandle2);
      CountSeconds(&hv_S4);
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      //****显示检测边缘

      DispLine(hv_WindowHandle, hv_RowEdgeFirst1-(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeFirst1-(hv_RectLength2*(hv_AngleCheck.TupleSin())), hv_RowEdgeFirst1+(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeFirst1+(hv_RectLength2*(hv_AngleCheck.TupleSin())));
      DispLine(hv_WindowHandle, hv_RowEdgeSecond1-(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeSecond1-(hv_RectLength2*(hv_AngleCheck.TupleSin())), hv_RowEdgeSecond1+(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeSecond1+(hv_RectLength2*(hv_AngleCheck.TupleSin())));
      DispLine(hv_WindowHandle, hv_RowEdgeFirst2-(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeFirst2-(hv_RectLength2*(hv_AngleCheck.TupleSin())), hv_RowEdgeFirst2+(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeFirst2+(hv_RectLength2*(hv_AngleCheck.TupleSin())));
      DispLine(hv_WindowHandle, hv_RowEdgeSecond2-(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeSecond2-(hv_RectLength2*(hv_AngleCheck.TupleSin())), hv_RowEdgeSecond2+(hv_RectLength2*(hv_AngleCheck.TupleCos())), 
          hv_ColumnEdgeSecond2+(hv_RectLength2*(hv_AngleCheck.TupleSin())));
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),1);
      hv_NumLeads = (hv_IntraDistance1.TupleLength())+(hv_IntraDistance2.TupleLength());
      hv_MinDistance = (hv_InterDistance1.TupleConcat(hv_InterDistance2)).TupleMin();
      HDevWindowStack::SetActive(hv_WindowHandleText);
      if (HDevWindowStack::IsOpen())
        SetPart(HDevWindowStack::GetActive(),0, 0, 119, hv_Width-1);
      if (HDevWindowStack::IsOpen())
        ClearWindow(HDevWindowStack::GetActive());
      disp_message(hv_WindowHandleText, (("Matching: Time: "+(((hv_S2-hv_S1)*1000).TupleString("5.2f")))+"ms , Score: ")+(hv_Score.TupleString("7.5f")), 
          "image", 20, 20, "green", "false");
      disp_message(hv_WindowHandleText, (("Measure:  Time: "+(((hv_S4-hv_S3)*1000).TupleString("5.2f")))+" ms, Num. leads: ")+(hv_NumLeads.TupleString("2d")), 
          "image", 50, 20, "red", "false");
      disp_message(hv_WindowHandleText, "          Min. lead dist: "+(hv_MinDistance.TupleString("6.3f")), 
          "image", 80, 20, "red", "false");
    }
    // Error variable 'hv_Error' activated
    hv_Error = 2;
    // dev_set_check ("~give_error")
    try
    {
      hv_Error = 2;
      GetMposition(hv_WindowHandle, &hv_R, &hv_C, &hv_Button);
    }
    catch(HalconCpp::HException e)
    {
      hv_Error = (int)e.ErrorCode();
      if (hv_Error < 0)
        throw e;
    }
    // Error variable 'hv_Error' deactivated
    // dev_set_check ("give_error")
    if (0 != (hv_Error!=2))
    {
      hv_Button = 0;
    }
  }
  HDevWindowStack::SetActive(hv_WindowHandleText);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  ClearShapeModel(hv_ModelID);
  CloseFramegrabber(hv_FGHandle);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


