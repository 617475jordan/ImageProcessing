///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Region, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionFillUp, ho_RegionDilation;
  HObject  ho_ImageReduced, ho_Model, ho_ModelTrans, ho_ImageSearch;
  HObject  ho_Region2;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_ModelID, hv_Area, hv_RowRef, hv_ColumnRef, hv_HomMat2D;
  HTuple  hv_Row, hv_Column, hv_Angle, hv_Scale, hv_Score;
  HTuple  hv_I, hv_HomMat2DIdentity, hv_HomMat2DTranslate;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DScale, hv_Mean, hv_Deviation;

  //This example program shows how to find scaled and rotated shape models.
  // dev_update_pc(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  ReadImage(&ho_Image, "green-dot");
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width,hv_Height,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"red");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  Threshold(ho_Image, &ho_Region, 0, 128);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 10000, 20000);
  FillUp(ho_SelectedRegions, &ho_RegionFillUp);
  DilationCircle(ho_RegionFillUp, &ho_RegionDilation, 5.5);
  ReduceDomain(ho_Image, ho_RegionDilation, &ho_ImageReduced);
  CreateScaledShapeModel(ho_ImageReduced, 5, HTuple(-45).TupleRad(), HTuple(90).TupleRad(), 
      "auto", 0.8, 1.0, "auto", "none", "ignore_global_polarity", 40, 10, &hv_ModelID);

  GetShapeModelContours(&ho_Model, hv_ModelID, 1);
  AreaCenter(ho_RegionFillUp, &hv_Area, &hv_RowRef, &hv_ColumnRef);
  VectorAngleToRigid(0, 0, 0, hv_RowRef, hv_ColumnRef, 0, &hv_HomMat2D);
  AffineTransContourXld(ho_Model, &ho_ModelTrans, hv_HomMat2D);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ModelTrans, HDevWindowStack::GetActive());
  ReadImage(&ho_ImageSearch, "green-dots");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ImageSearch, HDevWindowStack::GetActive());
  FindScaledShapeModel(ho_ImageSearch, hv_ModelID, HTuple(-45).TupleRad(), HTuple(90).TupleRad(), 
      0.8, 1.0, 0.5, 0, 0.5, "least_squares", 5, 0.8, &hv_Row, &hv_Column, &hv_Angle, 
      &hv_Scale, &hv_Score);
  {
  HTuple end_val27 = (hv_Score.TupleLength())-1;
  HTuple step_val27 = 1;
  for (hv_I=0; hv_I.Continue(end_val27, step_val27); hv_I += step_val27)
  {
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dTranslate(hv_HomMat2DIdentity, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]), 
        &hv_HomMat2DTranslate);
    HomMat2dRotate(hv_HomMat2DTranslate, HTuple(hv_Angle[hv_I]), HTuple(hv_Row[hv_I]), 
        HTuple(hv_Column[hv_I]), &hv_HomMat2DRotate);
    HomMat2dScale(hv_HomMat2DRotate, HTuple(hv_Scale[hv_I]), HTuple(hv_Scale[hv_I]), 
        HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]), &hv_HomMat2DScale);

    AffineTransContourXld(ho_Model, &ho_ModelTrans, hv_HomMat2DScale);
    GenRegionContourXld(ho_ModelTrans, &ho_Region2, "filled");
    Intensity(ho_Region2, ho_ImageSearch, &hv_Mean, &hv_Deviation);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ModelTrans, HDevWindowStack::GetActive());
  }
  }
  ClearShapeModel(hv_ModelID);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


